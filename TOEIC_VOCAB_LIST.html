<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>3D TOEIC単語ネットワーク</title>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', 'Helvetica Neue', sans-serif;
            overflow: hidden;
            background: #000;
        }
        #graph-container {
            width: 100vw;
            height: 100vh;
        }
        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(28, 28, 45, 0.95);
            padding: 25px;
            border-radius: 15px;
            max-width: 380px;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            color: #fff;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .info-panel h2 {
            margin: 0 0 20px 0;
            color: #fff;
            font-size: 24px;
            font-weight: 600;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }
        .info-panel .meaning-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .meaning-entry {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .meaning-entry:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .part-of-speech {
            color: #4A90E2;
            font-weight: 600;
            margin-right: 8px;
        }
        .word-meaning {
            color: rgba(255, 255, 255, 0.9);
        }
        .info-panel .level-badge {
            display: inline-block;
            background: #4A90E2;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            margin-bottom: 15px;
        }
        .info-panel .example-box {
            border-left: 3px solid #4A90E2;
            padding: 10px 15px;
            margin: 15px 0;
            background: rgba(74, 144, 226, 0.1);
        }
        .info-panel .example-en {
            color: #fff;
            font-style: italic;
            margin-bottom: 8px;
            line-height: 1.4;
        }
        .info-panel .example-jp {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            line-height: 1.4;
        }
        .info-panel .related-words {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .info-panel .related-word-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.15);
            padding: 4px 12px;
            border-radius: 15px;
            margin: 0 8px 8px 0;
            font-size: 12px;
            transition: background-color 0.3s;
            cursor: pointer;
        }
        .info-panel .related-word-badge:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        .highlighted-word {
            color: #FFFFFF;
            padding: 3px 8px;
            margin: 0 2px;
            display: inline-block;
            position: relative;
            font-weight: 600;
            background: linear-gradient(135deg, 
                rgba(41, 121, 255, 0.3) 0%, 
                rgba(41, 121, 255, 0.4) 50%, 
                rgba(41, 121, 255, 0.3) 100%);
            border: 1px solid rgba(41, 121, 255, 0.4);
            border-radius: 4px;
            text-shadow: 
                0 0 4px #fff,
                0 0 7px #fff,
                0 0 14px #2979FF,
                0 0 30px #2979FF,
                0 0 40px #2979FF;
            animation: soft-neon-flicker 4s infinite alternate;
        }
        
        .highlighted-word::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(41, 121, 255, 0.15);
            box-shadow: 
                0 0 10px #fff,
                0 0 20px #2979FF,
                0 0 30px #2979FF;
            opacity: 0;
            animation: soft-neon-pulse 3s ease-in-out infinite;
            border-radius: 4px;
            z-index: -1;
        }
        
        @keyframes soft-neon-flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                    0 0 4px #fff,
                    0 0 7px #fff,
                    0 0 14px #2979FF,
                    0 0 30px #2979FF,
                    0 0 40px #2979FF;
            }
            20%, 24%, 55% {
                text-shadow: 
                    0 0 2px #fff,
                    0 0 5px #fff,
                    0 0 10px #2979FF;
            }
        }
        
        @keyframes soft-neon-pulse {
            0% { opacity: 0.3; }
            50% { opacity: 0.7; }
            100% { opacity: 0.3; }
        }
        
        .highlighted-word:hover {
            animation: soft-neon-intense 0.5s ease-in-out infinite alternate;
            transform: scale(1.05);
            transition: transform 0.3s ease;
            background: linear-gradient(135deg, 
                rgba(41, 121, 255, 0.4) 0%, 
                rgba(41, 121, 255, 0.5) 50%, 
                rgba(41, 121, 255, 0.4) 100%);
        }
        
        @keyframes soft-neon-intense {
            from {
                text-shadow:
                    0 0 5px #fff,
                    0 0 10px #fff,
                    0 0 20px #2979FF,
                    0 0 35px #2979FF,
                    0 0 45px #2979FF;
            }
            to {
                text-shadow:
                    0 0 3px #fff,
                    0 0 7px #fff,
                    0 0 15px #2979FF,
                    0 0 25px #2979FF,
                    0 0 35px #2979FF;
            }
        }
        .word-category {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 5px;
        }
        /* リンクのアニメーション用の新しいスタイル */
        .chain-link {
            animation: glowPulse 2s infinite;
        }
        
        @keyframes glowPulse {
            0% {
                filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.7));
            }
            50% {
                filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.9));
            }
            100% {
                filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.7));
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
    <script src="https://unpkg.com/three-spritetext"></script>
    <script src="https://unpkg.com/3d-force-graph"></script>
</head>
<body>
    <div id="graph-container"></div>
    <div id="info-panel" class="info-panel">
        <h2 id="word-title"></h2>
        <div id="level" class="level-badge"></div>
        <div class="word-category">関連情報</div>
        <div class="meaning-box">
            <div id="word-meaning"></div>
        </div>
        <div class="word-category">例文</div>
        <div class="example-box">
            <div id="word-example-en" class="example-en"></div>
            <div id="word-example-jp" class="example-jp"></div>
        </div>
        <div class="related-words">
            <div class="word-category">関連語</div>
            <div id="related-words-list"></div>
        </div>
    </div>

    <script src="vocabularyData.js"></script>
    <script>
       
        const Graph = ForceGraph3D()
        (document.getElementById('graph-container'))
            .graphData(vocabularyData)
            .nodeLabel('label')
            .nodeColor(node => getNodeColor(node.group))
            .nodeRelSize(6)
            .linkWidth(0.76)
            .linkDirectionalParticles(3)
            .linkDirectionalParticleWidth(2)
            .linkDirectionalParticleSpeed(0.005)
            .onNodeClick(handleNodeClick)
            .onBackgroundClick(hideInfoPanel);
        
        // 初期状態でリンクを非表示にする
        Graph.linkVisibility(() => false);
        
        Graph.nodeThreeObject(node => {
            const sprite = new SpriteText(node.id);
            sprite.material.depthWrite = false;
            sprite.color = 'white';
            sprite.textHeight = 8;
            return sprite;
        });
        
        function getNodeColor(group) {
            const colors = {
                1: '#4A90E2',
                2: '#50E3C2',
                3: '#F5A623'
            };
            return colors[group] || '#ffffff';
        }
        
        function getRelatedNodes(nodeId) {
            return vocabularyData.links
                .filter(link => link.source.id === nodeId || link.target.id === nodeId)
                .map(link => {
                    const relatedNode = link.source.id === nodeId ? link.target : link.source;
                    return {
                        id: relatedNode.id,
                        label: vocabularyData.nodes.find(n => n.id === relatedNode.id).label
                    };
                });
        }
        
        // カスタムリンクジオメトリ生成関数
        function createChainLinkGeometry(startPoint, endPoint) {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(startPoint.x, startPoint.y, startPoint.z),
                new THREE.Vector3(
                    (startPoint.x + endPoint.x) / 2,
                    (startPoint.y + endPoint.y) / 2 + 10, // より大きなカーブ
                    (startPoint.z + endPoint.z) / 2
                ),
                new THREE.Vector3(endPoint.x, endPoint.y, endPoint.z)
            ]);
        
            const tubeGeometry = new THREE.TubeGeometry(curve, 64, 0.5, 8, false);
            return tubeGeometry;
        }
        
        // グローエフェクト用の改良されたマテリアル
        const glowMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color: { value: new THREE.Color(0x00BFFF) },  // より明るい青色 (DeepSkyBlue)
                glowIntensity: { value: 1.5 }  // 光沢の強さ
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 color;
                uniform float glowIntensity;
                varying vec2 vUv;
                
                void main() {
                    // パルスエフェクト
                    float pulse = 0.5 + 0.5 * sin(time * 2.0 + vUv.x * 10.0);
                    
                    // エッジグロー効果
                    float edgeGlow = pow(1.0 - abs(vUv.y - 0.5) * 2.0, 2.0);
                    
                    // 光沢効果
                    float shine = pow(max(0.0, sin(time * 3.0 + vUv.x * 15.0)), 8.0);
                    
                    // 最終的な輝度
                    float brightness = mix(0.5, 1.0, pulse * edgeGlow + shine) * glowIntensity;
                    
                    // より明るい色調整
                    vec3 brightColor = color + vec3(0.3) * shine;
                    
                    gl_FragColor = vec4(brightColor * brightness, 0.8);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        Graph.linkThreeObject(link => {
            const start = link.source;
            const end = link.target;
            const geometry = createChainLinkGeometry(start, end);
            
            const material = glowMaterial.clone();
            material.uniforms.color.value = new THREE.Color(0x00BFFF);
            material.uniforms.glowIntensity.value = 1.5;
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = { link };
            
            return mesh;
        });
        
        Graph.linkPositionUpdate((obj, { start, end }) => {
            if (obj.geometry) {
                const geometry = createChainLinkGeometry(start, end);
                obj.geometry.dispose();
                obj.geometry = geometry;
            }
            return false;
        });
        
        function highlightRelatedWords(text, relatedNodes) {
            let highlightedText = text;
            relatedNodes.forEach(node => {
                const regex = new RegExp(node.id, 'gi');
                highlightedText = highlightedText.replace(regex, `<span class="highlighted-word">${node.id}</span>`);
            });
            return highlightedText;
        }
        
        function handleNodeClick(node) {
            const infoPanel = document.getElementById('info-panel');
            document.getElementById('word-title').textContent = `${node.id} (${node.label})`;
            
            const meanings = node.meaning.split('\n').map(entry => {
                const [word, meaning] = entry.split(': ');
                const [mainWord, partOfSpeech] = word.split(' ');
                return `<div class="meaning-entry">
                    <span class="part-of-speech">${partOfSpeech}</span>
                    <span class="word-meaning">${mainWord}: ${meaning}</span>
                </div>`;
            }).join('');
            
            document.getElementById('word-meaning').innerHTML = meanings;
            document.getElementById('level').textContent = node.level;
        
            const relatedNodes = getRelatedNodes(node.id);
        
            document.getElementById('word-example-en').innerHTML = 
                highlightRelatedWords(node.exampleEn, relatedNodes);
            document.getElementById('word-example-jp').textContent = node.exampleJp;
        
            const relatedWordsHtml = relatedNodes
                .map(related => `<span class="related-word-badge">${related.id} (${related.label})</span>`)
                .join('');
            document.getElementById('related-words-list').innerHTML = relatedWordsHtml;
            
            infoPanel.style.display = 'block';
            
            // 選択したノードに関連するリンクのみを表示
            Graph.linkVisibility(link => 
                link.source.id === node.id || link.target.id === node.id
            );
            
            const connectedNodes = vocabularyData.links
                .filter(link => link.source.id === node.id || link.target.id === node.id)
                .map(link => link.source.id === node.id ? link.target : link.source);
            
            Graph.nodeColor(n => 
                n === node ? '#ff0000' : 
                connectedNodes.includes(n.id) ? '#ffff00' : 
                getNodeColor(n.group)
            );
        }
        
        function hideInfoPanel() {
            document.getElementById('info-panel').style.display = 'none';
            // 背景クリック時に全リンクを非表示に
            Graph
                .linkVisibility(() => false)
                .nodeColor(node => getNodeColor(node.group));
        }
        
        // カメラとコントロールの設定
        Graph.cameraPosition({ x: 0, y: 0, z: 200 });
        Graph.controls().enableDamping = true;
        Graph.controls().dampingFactor = 0.25;
        Graph.controls().rotateSpeed = 0.5;
        
        // ライティングの設定
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        Graph.scene().add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
        pointLight.position.set(5, 5, 5);
        Graph.scene().add(pointLight);
        
        // パーティクルの初期化
        let particles;
        function initParticles() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 1000; i++) {
                vertices.push(
                    Math.random() * 600 - 300,
                    Math.random() * 600 - 300,
                    Math.random() * 600 - 300
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({
                size: 0.5,
                color: 0xffffff,
                transparent: true,
                opacity: 0.5
            });
            particles = new THREE.Points(geometry, material);
            Graph.scene().add(particles);
        }
        
        initParticles();
        
        // アニメーションループ
        let time = 0;
        function animate() {
            time += 0.01;
            
            Graph.scene().traverse(obj => {
                if (obj.material && obj.material.uniforms) {
                    obj.material.uniforms.time.value = time;
                    // パルス効果の強度を動的に変更
                    obj.material.uniforms.glowIntensity.value = 1.2 + Math.sin(time) * 0.3;
                }
            });
        
            if (particles) {
                particles.rotation.x += 0.0001;
                particles.rotation.y += 0.0001;
            }
        
     
            requestAnimationFrame(animate);
        }
        
        animate();
    </script>
</body>
</html>